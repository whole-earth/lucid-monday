"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three"),r=require("./shaderMaterial.cjs.js"),n=require("three/examples/jsm/postprocessing/Pass"),t=require("./useFBO.cjs.js");function o(e){if(e&&e.__esModule)return e;var r=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var t=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(r,n,t.get?t:{enumerable:!0,get:function(){return e[n]}})}})),r.default=e,Object.freeze(r)}var i=o(e);function a(e=i.FrontSide){const r={value:new i.Matrix4};return Object.assign(new i.MeshNormalMaterial({side:e}),{viewMatrix:r,onBeforeCompile:e=>{e.uniforms.viewMatrix=r,e.fragmentShader="vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\n"+e.fragmentShader.replace("#include <normal_fragment_maps>","#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\n")}})}const l=r.shaderMaterial({causticsTexture:null,causticsTextureB:null,color:new i.Color,lightProjMatrix:new i.Matrix4,lightViewMatrix:new i.Matrix4},"varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }",`varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <${parseInt(i.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`),s=r.shaderMaterial({cameraMatrixWorld:new i.Matrix4,cameraProjectionMatrixInv:new i.Matrix4,normalTexture:null,depthTexture:null,lightDir:new i.Vector3(0,1,0),lightPlaneNormal:new i.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new i.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},"\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }","  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }"),c={depth:!0,minFilter:i.LinearFilter,magFilter:i.LinearFilter,type:i.UnsignedByteType},d={minFilter:i.LinearMipmapLinearFilter,magFilter:i.LinearFilter,type:i.FloatType,generateMipmaps:!0};exports.Caustics=(e,{frames:r=1,causticsOnly:o=!1,ior:u=1.1,backside:m=!1,backsideIOR:p=1.1,worldRadius:v=.3125,color:x=new i.Color("white"),intensity:f=.05,resolution:g=2024,lightSource:h=new i.Vector3(1,1,1),near:P=.1,far:y=0}={})=>{const w={frames:r,ior:u,color:x,causticsOnly:o,backside:m,backsideIOR:p,worldRadius:v,intensity:f,resolution:g,lightSource:h,near:P,far:y},M=new i.Group;M.name="caustics_group";const D=M,T=new i.OrthographicCamera,S=new i.Scene;S.name="caustics_scene";const b=e,F=new i.CameraHelper(T);F.name="caustics_helper";const z=w.resolution,j=t.useFBO(z,z,c),O=t.useFBO(z,z,c),W=t.useFBO(z,z,d),R=t.useFBO(z,z,d),I=a(),_=a(i.BackSide),C=new s,V=new n.FullScreenQuad(C),B=new i.Mesh(new i.PlaneGeometry(1,1),new l({transparent:!0,color:w.color,causticsTexture:W.texture,causticsTextureB:R.texture,blending:i.CustomBlending,blendSrc:i.OneFactor,blendDst:i.SrcAlphaFactor,depthWrite:!1}));B.name="caustics_plane",B.rotation.x=-Math.PI/2,B.renderOrder=2,M.add(S,B),M.updateWorldMatrix(!1,!0);let k=0;const N=new i.Vector3,U=new i.Frustum,A=new i.Matrix4,L=new i.Plane,q=new i.Vector3,E=new i.Vector3,G=new i.Box3,H=new i.Vector3,Q=[],$=[],J=[],K=[],X=new i.Vector3;for(let e=0;e<8;e++)Q.push(new i.Vector3),$.push(new i.Vector3),J.push(new i.Vector3),K.push(new i.Vector3);return{scene:S,group:M,helper:F,params:w,update:()=>{if(w.frames===1/0||k++<w.frames){var e;(null==(r=h)?void 0:r.isVector3)?q.copy(h).normalize():q.copy(D.worldToLocal(h.getWorldPosition(N)).normalize()),E.copy(q).multiplyScalar(-1),null==(e=S.parent)||e.matrixWorld.identity(),G.setFromObject(S,!0),Q[0].set(G.min.x,G.min.y,G.min.z),Q[1].set(G.min.x,G.min.y,G.max.z),Q[2].set(G.min.x,G.max.y,G.min.z),Q[3].set(G.min.x,G.max.y,G.max.z),Q[4].set(G.max.x,G.min.y,G.min.z),Q[5].set(G.max.x,G.min.y,G.max.z),Q[6].set(G.max.x,G.max.y,G.min.z),Q[7].set(G.max.x,G.max.y,G.max.z);for(let e=0;e<8;e++)$[e].copy(Q[e]);G.getCenter(H),Q.map((e=>e.sub(H)));const n=L.set(E,0);Q.map(((e,r)=>n.projectPoint(e,J[r])));const t=J.reduce(((e,r)=>e.add(r)),N.set(0,0,0)).divideScalar(J.length),o=J.map((e=>e.distanceTo(t))).reduce(((e,r)=>Math.max(e,r))),i=Q.map((e=>e.dot(q))).reduce(((e,r)=>Math.max(e,r)));T.position.copy(X.copy(q).multiplyScalar(i).add(H)),T.lookAt(S.localToWorld(H));const a=A.lookAt(T.position,H,N.set(0,1,0));if(T.left=-o,T.right=o,T.top=o,T.bottom=-o,T.near=w.near,w.far)T.far=w.far;else{const e=N.set(0,o,0).applyMatrix4(a),r=(T.position.y+e.y)/q.y;T.far=r}T.updateProjectionMatrix(),T.updateMatrixWorld();const l=$.map(((e,r)=>e.add(K[r].copy(q).multiplyScalar(-e.y/q.y)))),s=l.reduce(((e,r)=>e.add(r)),N.set(0,0,0)).divideScalar(l.length),c=2*l.map((e=>Math.hypot(e.x-s.x,e.z-s.z))).reduce(((e,r)=>Math.max(e,r)));B.scale.setScalar(c),B.position.copy(s),F.parent&&F.update(),_.viewMatrix.value=I.viewMatrix.value=T.matrixWorldInverse;const d=U.setFromProjectionMatrix(A.multiplyMatrices(T.projectionMatrix,T.matrixWorldInverse)).planes[4];C.cameraMatrixWorld=T.matrixWorld,C.cameraProjectionMatrixInv=T.projectionMatrixInverse,C.lightDir=E,C.lightPlaneNormal=d.normal,C.lightPlaneConstant=d.constant,C.near=T.near,C.far=T.far,C.resolution=w.resolution,C.size=o,C.intensity=w.intensity,C.worldRadius=w.worldRadius,S.visible=!0,b.setRenderTarget(j),b.clear(),S.overrideMaterial=I,b.render(S,T),b.setRenderTarget(O),b.clear(),w.backside&&(S.overrideMaterial=_,b.render(S,T)),S.overrideMaterial=null,C.ior=w.ior,B.material.lightProjMatrix=T.projectionMatrix,B.material.lightViewMatrix=T.matrixWorldInverse,C.normalTexture=j.texture,C.depthTexture=j.depthTexture,b.setRenderTarget(W),b.clear(),V.render(b),C.ior=w.backsideIOR,C.normalTexture=O.texture,C.depthTexture=O.depthTexture,b.setRenderTarget(R),b.clear(),w.backside&&V.render(b),b.setRenderTarget(null),w.causticsOnly&&(S.visible=!1)}var r},normalTarget:j,normalTargetB:O,causticsTarget:W,causticsTargetB:R}};
