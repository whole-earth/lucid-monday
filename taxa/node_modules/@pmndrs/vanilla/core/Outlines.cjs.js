"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three"),n=require("three/examples/jsm/utils/BufferGeometryUtils"),t=require("./shaderMaterial.cjs.js");function r(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,r.get?r:{enumerable:!0,get:function(){return e[t]}})}})),n.default=e,Object.freeze(n)}var i=r(e);const o=t.shaderMaterial({color:new i.Color("black"),opacity:1,thickness:.05},"\n   #include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   void main() {\n     #if defined (USE_SKINNING)\n\t   #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n\t   #include <morphtarget_vertex>\n\t   #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 transformedNormal = vec4(normal, 0.0);\n     vec4 transformedPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       transformedNormal = instanceMatrix * transformedNormal;\n       transformedPosition = instanceMatrix * transformedPosition;\n     #endif\n     vec3 newPosition = transformedPosition.xyz + transformedNormal.xyz * thickness;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n   }",`\n   uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <${parseInt(i.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`);exports.Outlines=function({color:e=new i.Color("black"),opacity:t=1,transparent:r=!1,thickness:a=.05,angle:c=Math.PI}){const s=new i.Group;let l={color:e,opacity:t,transparent:r,thickness:a,angle:c};function d(e){const t=s.parent;if(s.clear(),t&&t.geometry){let r;t.skeleton?(r=new i.SkinnedMesh,r.material=new o({side:i.BackSide}),r.bind(t.skeleton,t.bindMatrix),s.add(r)):t.isInstancedMesh?(r=new i.InstancedMesh(t.geometry,new o({side:i.BackSide}),t.count),r.instanceMatrix=t.instanceMatrix,s.add(r)):(r=new i.Mesh,r.material=new o({side:i.BackSide}),s.add(r)),r.geometry=e?n.toCreasedNormals(t.geometry,e):t.geometry}}function u(e){l={...l,...e};const n=s.children[0];if(n){const{transparent:e,thickness:t,color:r,opacity:i}=l;Object.assign(n.material,{transparent:e,thickness:t,color:r,opacity:i})}}return{group:s,updateProps(e){var n;const t=null!==(n=e.angle)&&void 0!==n?n:l.angle;t!==l.angle&&d(t),u(e)},generate(){d(l.angle),u(l)}}};
