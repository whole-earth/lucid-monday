"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var o=require("three"),n=require("./shaderMaterial.cjs.js");function e(o){if(o&&o.__esModule)return o;var n=Object.create(null);return o&&Object.keys(o).forEach((function(e){if("default"!==e){var i=Object.getOwnPropertyDescriptor(o,e);Object.defineProperty(n,e,i.get?i:{enumerable:!0,get:function(){return o[e]}})}})),n.default=o,Object.freeze(n)}var i=e(o);const r=n.shaderMaterial({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,cellThickness:.5,sectionThickness:1,cellColor:new i.Color,sectionColor:new i.Color,infiniteGrid:!1,followCamera:!1,worldCamProjPosition:new i.Vector3,worldPlanePosition:new i.Vector3},"\n      varying vec3 localPosition;\n      varying vec4 worldPosition;\n  \n      uniform vec3 worldCamProjPosition;\n      uniform vec3 worldPlanePosition;\n      uniform float fadeDistance;\n      uniform bool infiniteGrid;\n      uniform bool followCamera;\n  \n      void main() {\n        localPosition = position.xzy;\n        if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\n        \n        worldPosition = modelMatrix * vec4(localPosition, 1.0);\n        if (followCamera) {\n          worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\n          localPosition = (inverse(modelMatrix) * worldPosition).xyz;\n        }\n  \n        gl_Position = projectionMatrix * viewMatrix * worldPosition;\n      }\n    ",`\n      varying vec3 localPosition;\n      varying vec4 worldPosition;\n  \n      uniform vec3 worldCamProjPosition;\n      uniform float cellSize;\n      uniform float sectionSize;\n      uniform vec3 cellColor;\n      uniform vec3 sectionColor;\n      uniform float fadeDistance;\n      uniform float fadeStrength;\n      uniform float cellThickness;\n      uniform float sectionThickness;\n  \n      float getGrid(float size, float thickness) {\n        vec2 r = localPosition.xz / size;\n        vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n        float line = min(grid.x, grid.y) + 1.0 - thickness;\n        return 1.0 - min(line, 1.0);\n      }\n  \n      void main() {\n        float g1 = getGrid(cellSize, cellThickness);\n        float g2 = getGrid(sectionSize, sectionThickness);\n  \n        float dist = distance(worldCamProjPosition, worldPosition.xyz);\n        float d = 1.0 - min(dist / fadeDistance, 1.0);\n        vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\n  \n        gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\n        gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n        if (gl_FragColor.a <= 0.0) discard;\n  \n        #include <tonemapping_fragment>\n        #include <${parseInt(i.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n      }\n    `);exports.Grid=({args:o=[1,1],cellColor:n=new i.Color("#000000"),sectionColor:e=new i.Color("#2080ff"),cellSize:t=.5,sectionSize:l=1,followCamera:a=!1,infiniteGrid:s=!1,fadeDistance:c=100,fadeStrength:f=1,cellThickness:d=.5,sectionThickness:m=1,side:u=i.BackSide}={})=>{const g=new r({transparent:!0,side:u,...{cellSize:t,sectionSize:l,cellColor:n,sectionColor:e,cellThickness:d,sectionThickness:m},...{fadeDistance:c,fadeStrength:f,infiniteGrid:s,followCamera:a}}),P=new i.PlaneGeometry(o[0],o[1]),w=new i.Mesh(P,g);w.frustumCulled=!1;const C=new i.Plane,v=new i.Vector3(0,1,0),h=new i.Vector3(0,0,0);return{mesh:w,update:o=>{if(!w.parent)return;C.setFromNormalAndCoplanarPoint(v,h).applyMatrix4(w.matrixWorld);const n=w.material,e=n.uniforms.worldCamProjPosition,i=n.uniforms.worldPlanePosition;C.projectPoint(o.position,e.value),i.value.set(0,0,0).applyMatrix4(w.matrixWorld)}}};
